
/***************************start************************/
vec2 GetRsRp(float n1, float n2, float cos_i){
	cos_i = abs(cos_i);
	float cos_t = sqrt(1 - (n1*n1)/(n2*n2)*(1-cos_i*cos_i));
	float rs = (n1*cos_i-n2*cos_t)/(n1*cos_i+n2*cos_t); 
	float rp = (n2*cos_i-n1*cos_t)/(n1*cos_t+n2*cos_i); 

	return vec2(rs, rp);
}
mat3 GetRotateMatrix(float phi){
	mat3 M;
	float sin_2phi = sin(2*phi), cos_2phi = cos(2*phi);
	M[0] = vec3(1,0,0);
	M[1] = vec3(0,cos_2phi,-sin_2phi);
	M[2] = vec3(0,sin_2phi, cos_2phi);
	return M;
}
/****************************end***********************/


/****************************start************************/
	R[i] = GetRsRp(1.0f, 1.5f, dot(n, ray.dir));
	const float intensity = Intensity[tri.w], theta = 2*PI*rand(ray.seed); 
	S[i] = vec3(1, cos(theta),sin(theta))*intensity;
/****************************end************************/


/****************************start************************/
//R & I are reflectivity and intensity, i is reflection times plus one
	vec3 res = vec3(S[i--]); int i_max = i;
	vec3 s = vec3(epsilon); float phi = epsilon;
	for(; i >= 0;i--){
		//PolarInfo{ indir, normal, outdir}	
		vec3 d = polarInfoList[i].outdir;
		vec3 s_old = s;
		s = normalize(cross(polarInfoList[i].n, d));
		phi = acos(dot(s, s_old));

		res = GetRotateMatrix(phi)*res;
		const float Rs = R[i].x*R[i].x, Rp = R[i].y*R[i].y;
		mat3 Refl = mat3(vec3((Rs+Rp)/2, (Rs-Rp)/2, 0), vec3((Rs-Rp)/2, (Rs+Rp)/2,0), vec3(0,0,R[i].x*R[i].y)),
			Trans = mat3(vec3(1-(Rs+Rp)/2, (Rp-Rs)/2, 0), vec3((Rp-Rs)/2, 1-(Rs+Rp)/2,0), vec3(0,0,sqrt((1-Rs)*(1-Rp))));
		res = Refl*res + Trans*S[i];
	}
	vec3 s_cam = normalize(cross(vec3(0,0,-1),initDir));
	phi = acos(0);
	
	res = GetRotateMatrix(phi)*res;
	return vec4(res,1);
/****************************end************************/