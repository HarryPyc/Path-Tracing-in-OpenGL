#version 430    

layout(binding = 0, rgba32f)uniform image2D result;
layout (local_size_x = 32, local_size_y = 32) in;
uniform int Samples = 1;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 camPos;
uniform float Intensity[9];
uniform float Reflectivity[9];

const int SPECULAR = 0, DIFFUSE = 1, REFRACTION = 2, GLOSSY = 3;
const int WIDTH = 720, HEIGHT = 480;
const int MAX_BOUNCE = 6;

const float epsilon = 1e-4, inf = 1e6, PI = 3.1415926, glossiness = 0.6;
struct CSMeshData{
	vec3 color;
	int type;
	vec3 emission;
	float reflectivity;
	mat4 M;
	int numVert, numIdx, PADDING0, PADDING1;
};
layout(std140, binding = 1) uniform CSMeshBlock{
	CSMeshData CSdataList[2];
};

layout(std430, binding = 2) readonly buffer VertexLayer{
	vec4 Vertices[];
};
layout(std430, binding = 3) readonly buffer IndexLayer{
	unsigned int Indices[];
};


float seed;
float rand(vec2 co){
	seed++;
    return fract(sin(seed/Samples*dot(co ,vec2(12.9898,78.233))) * 43758.5453);
}
struct Ray{
	vec3 origin, dir;
	int depth, lastHit;
	vec2 seed;
};
float RayIntersectsTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2)
{
    vec3 edge1, edge2, h, s, q;
    float a,f,u,v,t=0;
    edge1 = v1 - v0;
    edge2 = v2 - v0;
    h = cross(ray.dir, edge2);
    a = dot(edge1, h);
    if (a > -epsilon && a < epsilon)
        return t;    // This ray is parallel to this triangle.
    f = 1.0/a;
    s = ray.origin - v0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
        return t;
    q = cross(s,edge1);
    v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0)
        return t;
    // At this stage we can compute t to find out where the intersection point is on the line.
    t = f * dot(edge2, q);
    return t;
}
struct Sphere{
	float radius;
	vec3 pos, emission, color;
	int type;
	float intersect(Ray ray){
		vec3 op = ray.origin - pos;
		float t, b=dot(op, ray.dir), det=b*b-dot(op, op)+radius*radius; //a=1
		if (det<=0) return 0; else det=sqrt(det); 
		return t = (-b-det)>epsilon? (-b-det) : max((-b+det), 0); 
	}
};
struct Cone{
	float theta;
	vec3 tip, axis, emission, color;
	int type;
	float intersect(Ray ray){
		vec3 co = ray.origin - tip; float cos2t = cos(radians(theta)); cos2t *= cos2t;
		float t, dotDV = dot(ray.dir, axis), dotCOV = dot(co, axis);
		float a = dotDV*dotDV - cos2t, b = 2*(dotDV*dotCOV-dot(ray.dir, co)*cos2t),
			  c = dotCOV*dotCOV-dot(co,co)*cos2t, delta = b*b-4*a*c;
		if(delta<=0) return 0; else delta = sqrt(delta);
		t = (-b+delta)/2/a>epsilon?(-b+delta)/2/a:max((-b-delta)/2/a,0);
		vec3 hit = ray.origin + t*ray.dir;
		if(dot(hit-tip, axis)<=0) return 0;
		return t;
	}
};
const float room_w = 300, room_h = 300, room_d = 1200;
shared Sphere spheres[] = {//Scene: radius, position, emission, color, material 
   //Walls and light source
   Sphere(1e5, vec3(-1e5, 0, 0),                       vec3(0),        vec3(.75,.25,.25),  DIFFUSE),//Left 
   Sphere(1e5, vec3(1e5+room_w, 0, 0),                 vec3(0),        vec3(.25,.25,.75),  DIFFUSE),//Rght 
   Sphere(1e5, vec3(0, 0, -1e5),                       vec3(0),        vec3(.25,.75,.25),  DIFFUSE),//Back 
   Sphere(1e5, vec3(0, 0, 1e5+room_d),                 vec3(0),        vec3(0.75),         DIFFUSE),//Frnt 
   Sphere(1e5, vec3(0,  1e5+room_h, 0),                vec3(0),        vec3(0.75),         DIFFUSE),//Top 
   Sphere(1e5, vec3(0, -1e5, 0),                       vec3(0),        vec3(0.75),         DIFFUSE),//Bottom 
   Sphere(600, vec3(room_w/2,room_h+600-2,room_d/2),   vec3(4),        vec3(1),            DIFFUSE),//Light 

   Sphere(40,  vec3(200,40,700),                       vec3(0),        vec3(.8,.2,.2),     DIFFUSE)            
}; 
 shared Cone cones[] = {
	Cone(15, vec3(100, 80, 500), vec3(0,-1,0),         vec3(0), vec3(0.8,.2,.2), DIFFUSE)
};

vec3 Trace(Ray ray){
	vec3[MAX_BOUNCE*2] emits, colors;

	int i;  int object; //sphere0, cone1
	//We cannot do recursion in shader, so I use for loop instead
	for(i = 0; i < MAX_BOUNCE*2;i++){
		//Detect intersection
		float t = inf; int id = -1;

		for(int j = 0; j<spheres.length();j++){
			float _t = spheres[j].intersect(ray);//small offset avoids self-intersection
			if(_t < t && _t > epsilon){
				t = _t;
				id = j;
				object = 0;
			}
		}
		for(int j = 0; j<cones.length();j++){
			float _t = cones[j].intersect(ray);//small offset avoids self-intersection
			if(_t < t && _t > epsilon){
				t = _t;
				id = j;
				object = 1;
			}
		}
		int vert_offset = 0, idx_offset = 0, hit_offset = 0;
		for(int c = 0; c < CSdataList.length();c++){
			for(int j = idx_offset; j<CSdataList[c].numIdx+idx_offset-2;j+=3){
				const vec3 v0 = vec3(Vertices[Indices[j]+vert_offset]), v1 = vec3(Vertices[Indices[j+1]+vert_offset]), v2 = vec3(Vertices[Indices[j+2]+vert_offset]);
				float _t = RayIntersectsTriangle(ray,v0,v1,v2);
				if(_t < t && _t>epsilon){
					t = _t;
					id = j; hit_offset = vert_offset;
					object = 2;
				}
			}
			vert_offset += CSdataList[c].numVert;
			idx_offset += CSdataList[c].numIdx;
		}

		if(id == -1 ) break;
		t-=0.05;if(t<epsilon)break;
		vec3 emission,color,normal, hit = ray.origin + ray.dir*t; int type;
		switch(object){
		case 0:{ emission = spheres[id].emission; color = spheres[id].color; normal = normalize(hit-spheres[id].pos);type = spheres[id].type;break;}
		case 1:{ emission = cones[id].emission; color = cones[id].color; 
				 vec3 cp = hit-cones[id].tip, bn = cross(cones[id].axis, cp); normal = normalize(cross(bn, cp)); type = cones[id].type; break;}
		case 2:{ const int index = int(Vertices[Indices[id]+hit_offset].w); emission = CSdataList[index].emission; color = CSdataList[index].color; type = CSdataList[index].type;
				 const vec3 v0 = vec3(Vertices[Indices[id]+hit_offset]), v1 = vec3(Vertices[Indices[id+1]+hit_offset]), v2 = vec3(Vertices[Indices[id+2]+hit_offset]); normal = normalize(cross(v1-v0,v2-v0));break;}
		default:
			break;
		}
		//internal reflection/refraction or not
		vec3 n = dot(normal,ray.dir)>0? -normal:normal;
		//Russian Roulette Path Termination
		float p = min(0.95, max(max(color.x, color.y), color.z));
		if(ray.depth++ >= MAX_BOUNCE)
			if(abs(rand(ray.seed))>p){
				emits[i] = emission;
				colors[i] = vec3(0);
				break;
			}
		//Different BRDFs
		if(type == SPECULAR){
			ray.dir = reflect(ray.dir,n);
		}
		else if(type == DIFFUSE){
			//Monte Carlo Integration
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),n):cross(vec3(1),n);
			u = normalize(u);
			vec3 v = cross(u,n);
			float w = rand(ray.seed), theta = rand(ray.seed);
			//uniformly sampling on hemisphere
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*n;
			ray.dir = d;
		}
		else if(type == REFRACTION){
			float nc = 1.0, ng = 1.5; //Refraction index
			bool inside = dot(normal,n)<0;
			//Snells Law
			float eta = inside? ng/nc : nc/ng, R0 = pow((nc-ng)/(nc+ng), 2), c = abs(dot(ray.dir, n));
			float k = 1.0 - eta * eta * (1.0 - c*c);
			if(k < 0)
				ray.dir = reflect(ray.dir, n);
			else{
				//Shilick's approximation of Fresnel's equation
				float Re = R0 + (1-R0)*pow(1-c,5);
				if(abs(rand(ray.seed))<Re)
					ray.dir = reflect(ray.dir, n);
				else{
					ray.dir= (eta * ray.dir - (eta * dot(n, ray.dir) + sqrt(k)) * n);
				}
			}
		}else if(type == GLOSSY){
			vec3 r = reflect(ray.dir, n);
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),r):cross(vec3(1),r);
			u = normalize(u);
			vec3 v = cross(u,r);
			float w = rand(ray.seed) * glossiness, theta = rand(ray.seed);
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*r;
			ray.dir = d;
		}

		ray.origin = hit;
		ray.lastHit = id;
		emits[i] = emission;
		colors[i] = color;
	}
	vec3 res = vec3(0);
	for(; i >=0;i--){
		res = emits[i] + colors[i]*res;
	}
	return res;
}
void main(void)
{
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	if(pixel.x>=WIDTH || pixel.y>=HEIGHT)
		return;
	//start ray tracing
	vec2 pos = vec2(pixel)/vec2(WIDTH, HEIGHT);
	pos += vec2(rand(pixel), rand(pixel))*2e-3;//MSAA
	vec3 dir = mix(mix(ray00,ray10,pos.x), mix(ray01,ray11,pos.x), pos.y);
	vec3 color = Trace(Ray(camPos, normalize(dir), 0 , -1 ,pixel));

	pixel.y = HEIGHT - pixel.y - 1;
	color += vec3(imageLoad(result, pixel))*(Samples-1);
	barrier();
	imageStore(result, pixel, vec4(color/Samples,1));
}