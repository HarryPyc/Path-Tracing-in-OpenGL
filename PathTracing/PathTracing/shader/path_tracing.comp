#version 430    
layout(binding = 0, rgba32f)uniform image2D result;
layout (local_size_x = 8, local_size_y = 8) in;
uniform int Samples = 1;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 camPos;

const int SPECULAR = 0, DIFFUSE = 1, REFRACTION = 2, GLOSSY = 3;
const int WIDTH = 1280, HEIGHT = 720;
const int MAX_BOUNCE = 6;
//const vec3 camPos = vec3(0,0,150), 
//		   ray00 = normalize(vec3(-80,-45,45)-camPos), ray01 = normalize(vec3(-80,45,45)-camPos),
//		   ray10 = normalize(vec3( 80,-45,45)-camPos), ray11 = normalize(vec3( 80,45,45)-camPos);

const float epsilon = 1e-4, inf = 1e6, PI = 3.1415926, glossiness = 0.6;

float seed;
float rand(vec2 co){
	seed++;
    return fract(sin(Samples/seed*dot(co ,vec2(12.9898,78.233))) * 43758.5453);
}
struct Ray{
	vec3 origin, dir;
	int depth, lastHit;
	vec2 seed;
};
struct Sphere{
	float radius;
	vec3 pos, emission, color;
	int type;
	float intersect(Ray ray){
		vec3 op = ray.origin - pos;
		float t, b=dot(op, ray.dir), det=b*b-dot(op, op)+radius*radius; //a=1
		if (det<=0) return 0; else det=sqrt(det); 
		return t = (-b-det)>epsilon? (-b-det) : max((-b+det), 0); 
	}
};
Sphere spheres[] = {//Scene: radius, position, emission, color, material 
   Sphere(10,  vec3(65, -35, 30),      vec3(0,0,0),    vec3(0.2,0.2,0.8),  DIFFUSE),//Mirr 
   Sphere(15,  vec3( 15, -30, 25),     vec3(0.5),      vec3(0.8,0.8,0.2),  DIFFUSE),//Mirr 
   Sphere(20,  vec3(-10, -25, -10),    vec3(0,0,0),    vec3(0.8,0.8,0.2),  SPECULAR),//Mirr 
   Sphere(20,  vec3(-45, -25, 30),     vec3(0,0,0),    vec3(0.9),          REFRACTION),//Mirr 
   Sphere(20,  vec3(45,-25, -10),      vec3(0,0,0),    vec3(0.9),          GLOSSY),//Glas 
   Sphere(1e5, vec3(-1e5-80, 0, 0),    vec3(0),        vec3(.75,.25,.25),  DIFFUSE),//Left 
   Sphere(1e5, vec3(1e5+80, 0, 0),     vec3(0),        vec3(.25,.25,.75),  DIFFUSE),//Rght 
   Sphere(1e5, vec3(0, 0, -1e5-45),    vec3(0),        vec3(.25,.75,.25),  DIFFUSE),//Back 
   Sphere(1e5, vec3(0, 0, 1e5+200),    vec3(0),        vec3(0.75),         DIFFUSE),//Frnt 
   Sphere(1e5, vec3(0, -1e5-45, 0),    vec3(0),        vec3(0.75),         DIFFUSE),//Bottom 
   Sphere(1e5, vec3(0,  1e5+45, 0),    vec3(0),        vec3(0.75),         DIFFUSE),//Top 
   Sphere(600, vec3(0,644,0),          vec3(4),        vec3(1),            DIFFUSE) //Lite 
 }; 

vec3 Trace(Ray ray){
	vec3[MAX_BOUNCE*2] emits, colors;
	int i; float f = 1.0;
	for(i = 0; i < MAX_BOUNCE*2;i++){
		float t = inf; int id = -1;
		for(int j = 0; j<spheres.length();j++){
			float _t = spheres[j].intersect(ray)-0.05;
			if(_t < t && _t > epsilon){
				t = _t;
				id = j;
			}
		}
		if(id == -1 ) break;
		
		const Sphere obj = spheres[id];
		vec3 hit = ray.origin + ray.dir*t;
		vec3 normal = normalize(hit-obj.pos);
		vec3 n = dot(normal,ray.dir)>0? -normal:normal;
		if(id == ray.lastHit && obj.type != REFRACTION && dot(n,normal)<0) break;
		//Russian Roulette Path Termination
		float p = min(0.95, max(max(obj.color.x, obj.color.y), obj.color.z));
		if(ray.depth++ >= MAX_BOUNCE)
			if(abs(rand(ray.seed))>p){
				emits[i] = obj.emission;
				colors[i] = vec3(0);
				break;
			}
		if(obj.type == SPECULAR){
			ray.dir = reflect(ray.dir,n);
		}
		else if(obj.type == DIFFUSE){
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),n):cross(vec3(1),n);
			u = normalize(u);
			vec3 v = cross(u,n);
			float w = rand(ray.seed), theta = rand(ray.seed);
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*n;
			ray.dir = d;

		}
		else if(obj.type == REFRACTION){
			float nc = 1.0, ng = 1.5; //Refraction index
			bool inside = dot(normal,n)<0;
			float eta = inside? ng/nc : nc/ng, R0 = pow((nc-ng)/(nc+ng), 2), c = abs(dot(ray.dir, n));
			float k = 1.0 - eta * eta * (1.0 - c*c);
			if(k < 0)
				ray.dir = reflect(ray.dir, n);
			else{
				float Re = R0 + (1-R0)*pow(1-c,5);
				if(abs(rand(ray.seed))<Re)
					ray.dir = reflect(ray.dir, n);
				else{
					ray.dir= (eta * ray.dir - (eta * dot(n, ray.dir) + sqrt(k)) * n);
				}
			}
		}else if(obj.type == GLOSSY){
			vec3 r = reflect(ray.dir, n);
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),r):cross(vec3(1),r);
			u = normalize(u);
			vec3 v = cross(u,r);
			float w = rand(ray.seed) * glossiness, theta = rand(ray.seed);
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*r;
			ray.dir = d;
		}

		ray.origin = hit;
		ray.lastHit = id;
		emits[i] = obj.emission;
		colors[i] = obj.color * f;
	}
	vec3 res = vec3(0);
	for(; i >=0;i--){
		res = emits[i] + colors[i]*res;
	}
	return res;
}
void main(void)
{
	vec3 color;
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	if(pixel.x>=WIDTH || pixel.y>=HEIGHT)
		return;
	vec2 pos = vec2(pixel)/vec2(WIDTH, HEIGHT);
	pos += vec2(rand(pixel), rand(pixel))*2e-3;
	vec3 dir = mix(mix(ray00,ray10,pos.x), mix(ray01,ray11,pos.x), pos.y);
	color = Trace(Ray(camPos, normalize(dir), 0 , -1 ,pixel));

	color += vec3(imageLoad(result, pixel))*(Samples-1);
	barrier();
	imageStore(result, pixel, vec4(color/Samples,1));
}