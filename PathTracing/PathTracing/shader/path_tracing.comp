#version 430    
layout(binding = 0, rgba32f)uniform image2D result;
layout (local_size_x = 8, local_size_y = 8) in;

const int SPECULAR = 0, DIFFUSE = 1, REFRACTION = 2;
const int WIDTH = 1280, HEIGHT = 720;
const vec3 camPos = vec3(0,0,150), 
		   ray00 = normalize(vec3(-80,-45,45)-camPos), ray01 = normalize(vec3(-80,45,45)-camPos),
		   ray10 = normalize(vec3( 80,-45,45)-camPos), ray11 = normalize(vec3( 80,45,45)-camPos);
const double epsilon = 1e-4, inf = 1e6, PI = 3.1415926;

double rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
struct Ray{
	vec3 origin, dir;
	int depth;
	vec2 seed;
};
struct Sphere{
	double radius;
	vec3 pos, emission, color;
	int type;
	double intersect(Ray ray){
		vec3 op = pos - ray.origin;
		double t, b=dot(op, ray.dir), det=b*b-dot(op, op)+radius*radius; 
		if (det<0) return 0; else det=sqrt(det); 
		return (t=b-det)>epsilon ? t : ((t=b+det)>epsilon ? t : 0); 
	}
};
Sphere spheres[] = {//Scene: radius, position, emission, color, material 
   Sphere(30,  vec3(-40, -15, 0),       vec3(0),     vec3(0,1,1), SPECULAR),//Mirr 
   Sphere(30,vec3(45,-15,20),       vec3(0),vec3(1,1,0), REFRACTION),//Glas 
   Sphere(1e5, vec3(-1e5-80, 0, 0), vec3(0),vec3(0.75,0.25,0.25),DIFFUSE),//Left 
   Sphere(1e5, vec3(1e5+80, 0, 0),vec3(0),vec3(0.25,0.25,0.75),DIFFUSE),//Rght 
   Sphere(1e5, vec3(0, 0, -1e5-45),     vec3(0),vec3(.75,.75,.75),DIFFUSE),//Back 
   //Sphere(1e5, vec3(0, 0, 1e5+45), vec3(0),vec3(0,0,0),           DIFFUSE),//Frnt 
   Sphere(1e5, vec3(0, -1e5-45, 0),    vec3(0),vec3(.75,.75,.75),DIFFUSE),//Bottom 
   Sphere(1e5, vec3(0,  1e5+45, 0),    vec3(0),vec3(.75,.75,.75),DIFFUSE),//Top 
   Sphere(600, vec3(0,644,0),vec3(12,12,12),  vec3(0), DIFFUSE) //Lite 
 }; 

vec3 Trace(Ray ray){
	double t = inf; int id = -1;
	for(int i = 0; i<spheres.length();i++){
		double _t = spheres[i].intersect(ray);
		if(_t < t && _t > epsilon){
			t = _t;
			id = i;
		}
	}
	if(id != -1)
		return spheres[id].color;
	return vec3(0);
}
void main(void)
{
	vec3 color = vec3(0);
//	vec3 dir = (gl_WorkGroupID.x/WIDTH*2-1)*vec3(0.577,0,0) + (gl_WorkGroupID.y/HEIGHT*2-1)*vec3(0,0.325,0)
//		+ camDir;
//	for(int i = 0; i < 4; i++){
//		for(int j = 0; j < 4; j++){
//			vec2 seed = vec2(i,j);
//			double theta = rand(seed);
//			//vec3 turb = float(epsilon)*vec3(cos(float(2*PI*theta)), sin(float(2*PI*theta)), 0);
//			Ray ray = Ray(camPos, normalize(dir), 0, gl_GlobalInvocationID.xy);
//			color += Trace(ray);
//		}
//	}
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	if(pixel.x>WIDTH || pixel.y>HEIGHT)
		return;
	vec2 pos = vec2(pixel)/vec2(WIDTH, HEIGHT);
	vec3 dir = mix(mix(ray00,ray10,pos.x), mix(ray01,ray11,pos.x), pos.y);
	color = Trace(Ray(camPos, normalize(dir),0,pixel));

	color = pow(color, vec3(1/2.2));//Gamma Correction

	imageStore(result, pixel, vec4(color,1));
}