#version 430    

layout(binding = 0, rgba32f)uniform image2D result;
layout (local_size_x = 32, local_size_y = 32) in;
uniform int Samples = 1;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 camPos;
uniform float Intensity[9];
uniform float Reflectivity[9];

uniform sampler2D mug_normal;
uniform sampler2D table;

const int SPECULAR = 0, DIFFUSE = 1, REFRACTION = 2, GLOSSY = 3;
const int MAX_BOUNCE = 4, TREE_SIZE = 512;
const float room_w = 300, room_h = 300, room_d = 1200;

const float epsilon = 1e-4, inf = 1e6, PI = 3.1415926, glossiness = 0.6;
struct CSMeshData{
	vec3 color;
	int type;
	vec3 emission;
	float reflectivity;
	mat4 M;
	int numVert, numIdx, PADDING0, PADDING1;
};
struct TreeNode {
	unsigned int axis;int firstTriangle; int triangleCount; int isLeaf; 
	int left, right;
	float val, PADDING;
};
layout(std140, binding = 1) uniform CSMeshBlock{
	CSMeshData CSdataList[2];
};

layout(std430, binding = 2) readonly buffer VertexLayer{
	vec4 Vertices[];
};
layout(std430, binding = 3) readonly buffer TriangleLayer{
	uvec4 Triangles[];
};
layout(std140, binding = 4) uniform KdTreeBlock{
	TreeNode nodeList[TREE_SIZE];
};
layout(std430, binding = 5) readonly buffer TexCoordLayer{
	vec2 tex_coords[];
};

const TreeNode treeRoot = nodeList[0];
struct Ray{
	vec3 origin, dir;
	int depth, lastHit;
	vec2 seed;
};
bool RayIntersectsNode(Ray ray, vec3 minBb, vec3 maxBb, float tMin, float tMax, out float t0, out float t1){
	vec3 invD = vec3(1)/vec3(ray.dir);
	vec3 t0s = (minBb - ray.origin) * invD;
  	vec3 t1s = (maxBb - ray.origin) * invD;
    
  	vec3 tsmaller = min(t0s, t1s);
    vec3 tbigger  = max(t0s, t1s);
    
    t0 =  max(tMin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));
    t1 =  min(tMax, min(tbigger[0], min(tbigger[1], tbigger[2])));

	return (t0 < t1);
}
float RayIntersectsTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float u, out float v)
{
    vec3 edge1, edge2, h, s, q;
    float a,f,t=0;
    edge1 = v1 - v0;
    edge2 = v2 - v0;
    h = cross(ray.dir, edge2);
    a = dot(edge1, h);
    if (a > -epsilon && a < epsilon)
        return t;    // This ray is parallel to this triangle.
    f = 1.0/a;
    s = ray.origin - v0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
        return t;
    q = cross(s,edge1);
    v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0)
        return t;
    // At this stage we can compute t to find out where the intersection point is on the line.
    t = f * dot(edge2, q);
    return t;
}
struct HitState{
	float t, u, v;
	int id;
}Hit;
struct SearchState{
	int nodeptr; float tMin, tMax;
};
//class Stack{
//	SearchState array[8];
//	int top ;
//	void init(){ top = -1;}
//	SearchState pop(){
//		if(top>=0){
//			SearchState state = array[top];top--; return state;
//		}
//		return SearchState(0,0,0);
//	}
//	void push(SearchState state){ 
//		if(top<array.length()-1){
//			top++; array[top] = state;
//		}
//	}
//	bool empty(){ return top<0; }
//}stack;
void search_tree(Ray ray, TreeNode node, float tMin, float tMax){

	float global_tMin = tMin, global_tMax = tMax;
	tMax = global_tMin; //stack.init();
	TreeNode root = treeRoot; bool push_down;
	while(tMax < global_tMax){
//		if(stack.empty()){node = root; tMin = tMax; tMax = global_tMax; push_down = true;}
//		else{ SearchState state = stack.pop(); node = nodeList[state.nodeptr]; 
//			tMin = state.tMin; tMax = state.tMax; push_down = false;}
		node = root; tMin = tMax; tMax = global_tMax; push_down = true;
		while(node.isLeaf != 1){
			const uint a = node.axis;
			float o = ray.origin[a],d = ray.dir[a];
		
			float tSplit = (node.val-o)/d;
			TreeNode first, second; int sec_ptr;
			if(node.val - o>0){ first = nodeList[node.left]; second = nodeList[node.right]; sec_ptr = node.right;}
			else{ first = nodeList[node.right]; second = nodeList[node.left]; sec_ptr = node.left;}
	
			if(tSplit < 0 || tSplit>=tMax)
				node = first;
			else if(tSplit <= tMin){
				node = second;;
			}
			else{
				//stack.push(SearchState(sec_ptr, tSplit, tMax));
				node = first; tMax = tSplit; push_down = false;
			}
			if(push_down) root = node;
		}

		for(int i = node.firstTriangle; i < node.firstTriangle+node.triangleCount; i++){
			const uvec3 index = uvec3(Triangles[i]);
			const vec4 v0 = Vertices[index.x], v1 = Vertices[index.y],  v2 = Vertices[index.z];
			float _u,_v;
			float _t = RayIntersectsTriangle(ray, vec3(v0), vec3(v1), vec3(v2),_u,_v);
			if(_t < Hit.t && _t > epsilon){
				Hit.t = _t; Hit.u = _u; Hit.v = _v;
				Hit.id = i;
			}
		}
		if(Hit.id != -1) return;	
	}
}

float seed;
float rand(vec2 co){
	seed++;
    return fract(sin(seed/Samples*dot(co ,vec2(12.9898,78.233))) * 43758.5453);
}


//struct Sphere{
//	float radius;
//	vec3 pos, emission, color;
//	int type;
//	float intersect(Ray ray){
//		vec3 op = ray.origin - pos;
//		float t, b=dot(op, ray.dir), det=b*b-dot(op, op)+radius*radius; //a=1
//		if (det<=0) return 0; else det=sqrt(det); 
//		return t = (-b-det)>epsilon? (-b-det) : max((-b+det), 0); 
//	}
//};
//struct Cone{
//	float theta;
//	vec3 tip, axis, emission, color;
//	int type;
//	float intersect(Ray ray){
//		vec3 co = ray.origin - tip; float cos2t = cos(radians(theta)); cos2t *= cos2t;
//		float t, dotDV = dot(ray.dir, axis), dotCOV = dot(co, axis);
//		float a = dotDV*dotDV - cos2t, b = 2*(dotDV*dotCOV-dot(ray.dir, co)*cos2t),
//			  c = dotCOV*dotCOV-dot(co,co)*cos2t, delta = b*b-4*a*c;
//		if(delta<=0) return 0; else delta = sqrt(delta);
//		t = (-b+delta)/2/a>epsilon?(-b+delta)/2/a:max((-b-delta)/2/a,0);
//		vec3 hit = ray.origin + t*ray.dir;
//		if(dot(hit-tip, axis)<=0) return 0;
//		return t;
//	}
//};

//shared Sphere spheres[] = {//Scene: radius, position, emission, color, material 
//   //Walls and light source
//   Sphere(1e5, vec3(-1e5, 0, 0),                       vec3(0),        vec3(.75,.25,.25),  DIFFUSE),//Left 
//   Sphere(1e5, vec3(1e5+room_w, 0, 0),                 vec3(0),        vec3(.25,.25,.75),  DIFFUSE),//Rght 
//   Sphere(1e5, vec3(0, 0, -1e5),                       vec3(0),        vec3(.25,.75,.25),  DIFFUSE),//Back 
//   Sphere(1e5, vec3(0, 0, 1e5+room_d),                 vec3(0),        vec3(0.75),         DIFFUSE),//Frnt 
//   Sphere(1e5, vec3(0,  1e5+room_h, 0),                vec3(0),        vec3(0.75),         DIFFUSE),//Top 
//   Sphere(1e5, vec3(0, -1e5, 0),                       vec3(0),        vec3(0.75),         DIFFUSE),//Bottom 
//   Sphere(600, vec3(room_w/2,room_h+600-2,room_d/2),   vec3(4),        vec3(1),            DIFFUSE),//Light 
//
//   Sphere(40,  vec3(200,40,700),                       vec3(0),        vec3(.8,.2,.2),     DIFFUSE)            
//}; 
// shared Cone cones[] = {
//	Cone(15, vec3(100, 80, 500), vec3(0,-1,0),         vec3(0), vec3(0.8,.2,.2), DIFFUSE)
//};
//
vec3 Trace(Ray ray){
	vec3[MAX_BOUNCE*2] emits, colors;

	int i;  int object; //sphere0, cone1
	//We cannot do recursion in shader, so I use for loop instead
	for(i = 0; i < MAX_BOUNCE*2;i++){
		//Detect intersection
		Hit.t = inf, Hit.id = -1;

//		for(int j = 0; j<spheres.length();j++){
//			float _t = spheres[j].intersect(ray);//small offset avoids self-intersection
//			if(_t < t && _t > epsilon){
//				t = _t;
//				id = j;
//				object = 0;
//			}
//		}
//		for(int j = 0; j<cones.length();j++){
//			float _t = cones[j].intersect(ray);//small offset avoids self-intersection
//			if(_t < t && _t > epsilon){
//				t = _t;
//				id = j;
//				object = 1;
//			}
//		}
		//Brute force
		for(int j = 0; j < Triangles.length(); j++){
			const vec4 v0 = Vertices[Triangles[j].x], v1 = Vertices[Triangles[j].y],  v2 = Vertices[Triangles[j].z];
			float _u,_v;
			float _t = RayIntersectsTriangle(ray, vec3(v0), vec3(v1), vec3(v2), _u, _v);
			if(_t < Hit.t && _t > epsilon){
			Hit.t = _t; Hit.u = _u; Hit.v = _v;
			Hit.id = j;
			object = 2;
			}
		}
		//search kd tree
//		Hit.t = inf; Hit.id = -1;
//		float tMin, tMax;
//		if(RayIntersectsNode(ray, vec3(0), vec3(300), -1e5, 1e5, tMin, tMax)){
//			search_tree(ray, treeRoot, tMin, tMax);
//			if(Hit.id != -1 && t > Hit.t){
//				t = Hit.t; id = int(Hit.id);
//				object = 2;
//			}
//		}
		/*---------------------------*/
		if(Hit.id == -1 ){ emits[i] = vec3(0.4,0.4,0.6);break;}
		Hit.t-=0.05;if(Hit.t<epsilon)break;
		vec3 emission,color,normal, hit = ray.origin + ray.dir*Hit.t; int type;
//		switch(object){
//		case 0:{ emission = spheres[id].emission; color = spheres[id].color; normal = normalize(hit-spheres[id].pos);type = spheres[id].type;break;}
//		case 1:{ emission = cones[id].emission; color = cones[id].color; 
//				 vec3 cp = hit-cones[id].tip, bn = cross(cones[id].axis, cp); normal = normalize(cross(bn, cp)); type = cones[id].type; break;}
//		case 2:{ const uvec4 tri = Triangles[id]; emission = CSdataList[tri.w].emission; color = CSdataList[tri.w].color; type = CSdataList[tri.w].type;
//				 const vec3 v0 = vec3(Vertices[tri.x]), v1 = vec3(Vertices[tri.y]), v2 = vec3(Vertices[tri.z]); normal = normalize(cross(v1-v0,v2-v0));break;}
//		default:
//			break;
//		}
		const uvec4 tri = Triangles[Hit.id]; type = CSdataList[tri.w].type;
		const vec3 v0 = vec3(Vertices[tri.x]), v1 = vec3(Vertices[tri.y]), v2 = vec3(Vertices[tri.z]); 
		vec2 uv = Hit.u*tex_coords[tri.x]+Hit.v*tex_coords[tri.y]+(1-Hit.u-Hit.v)*tex_coords[tri.z];
		if(tri.w == 0){
			emission = CSdataList[tri.w].emission; color = CSdataList[tri.w].color; 
			//normal = vec3(texture2D(mug_normal,uv));
			normal = normalize(cross(v1-v0,v2-v0));
		}else if(tri.w == 1){
			normal = normalize(cross(v1-v0,v2-v0));
			emission = vec3(0); color = vec3(texture2D(table,uv));
		}

		//internal reflection/refraction or not
		vec3 n = dot(normal,ray.dir)>0? -normal:normal;
		//Russian Roulette Path Termination
		float p = min(0.95, max(max(color.x, color.y), color.z));
		if(ray.depth++ >= MAX_BOUNCE)
			if(abs(rand(ray.seed))>p){
				emits[i] = emission;
				colors[i] = vec3(0);
				break;
			}
		//Different BRDFs
		if(type == SPECULAR){
			ray.dir = reflect(ray.dir,n);
		}
		else if(type == DIFFUSE){
			//Monte Carlo Integration
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),n):cross(vec3(1),n);
			u = normalize(u);
			vec3 v = cross(u,n);
			float w = rand(ray.seed), theta = rand(ray.seed);
			//uniformly sampling on hemisphere
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*n;
			ray.dir = d;
		}
		else if(type == REFRACTION){
			float nc = 1.0, ng = 1.5; //Refraction index
			bool inside = dot(normal,n)<0;
			//Snells Law
			float eta = inside? ng/nc : nc/ng, R0 = pow((nc-ng)/(nc+ng), 2), c = abs(dot(ray.dir, n));
			float k = 1.0 - eta * eta * (1.0 - c*c);
			if(k < 0)
				ray.dir = reflect(ray.dir, n);
			else{
				//Shilick's approximation of Fresnel's equation
				float Re = R0 + (1-R0)*pow(1-c,5);
				if(abs(rand(ray.seed))<Re)
					ray.dir = reflect(ray.dir, n);
				else{
					ray.dir= (eta * ray.dir - (eta * dot(n, ray.dir) + sqrt(k)) * n);
				}
			}
		}else if(type == GLOSSY){
			vec3 r = reflect(ray.dir, n);
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),r):cross(vec3(1),r);
			u = normalize(u);
			vec3 v = cross(u,r);
			float w = rand(ray.seed) * glossiness, theta = rand(ray.seed);
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*r;
			ray.dir = d;
		}

		ray.origin = hit;
		ray.lastHit = Hit.id;
		emits[i] = emission;
		colors[i] = color;
	}
	vec3 res = vec3(0);
	for(; i >=0;i--){
		res = emits[i] + colors[i]*res;
	}
	return res;
}
void main(void)
{
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(result);
	if(pixel.x>=size.x || pixel.y>=size.y)
		return;
	//start ray tracing
	vec3 color;
	vec2 pos = vec2(pixel)/vec2(size);
	pos += vec2(rand(pixel), rand(pixel))*2e-3;//MSAA
	vec3 dir = mix(mix(ray00,ray10,pos.x), mix(ray01,ray11,pos.x), pos.y);
	color = Trace(Ray(camPos, normalize(dir), 0 , -1 ,pixel));

	pixel.y = size.y - pixel.y - 1;
	color += vec3(imageLoad(result, pixel))*(Samples-1);
	barrier();
	imageStore(result, pixel, vec4(color/Samples,1));
}