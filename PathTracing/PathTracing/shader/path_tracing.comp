#version 430    

layout(binding = 0, rgba32f)uniform image2D result;
layout (local_size_x = 32, local_size_y = 32) in;
uniform int Samples = 1;
uniform vec3 ray00;
uniform vec3 ray01;
uniform vec3 ray10;
uniform vec3 ray11;
uniform vec3 camPos;
uniform float Intensity[4];
uniform float Reflectivity[4];

uniform sampler2D oldman_temp;

const int SPECULAR = 0, DIFFUSE = 1, REFRACTION = 2, GLOSSY = 3;
const int MAX_BOUNCE = 4, TREE_SIZE = 512;
const float room_w = 300, room_h = 300, room_d = 1200;

const float epsilon = 1e-4, inf = 1e6, PI = 3.141592653589793238463, glossiness = 0.5;
struct CSMeshData{
	vec3 color;
	int type;
	vec3 emission;
	float reflectivity;
	mat4 M;
	int numVert, numIdx, PADDING0, PADDING1;
};
struct TreeNode {
	unsigned int axis;int firstTriangle; int triangleCount; int isLeaf; 
	int left, right;
	float val, PADDING;
};
layout(std140, binding = 1) uniform CSMeshBlock{
	CSMeshData CSdataList[4];
};

layout(std430, binding = 2) readonly buffer VertexLayer{
	vec4 Vertices[];
};
layout(std430, binding = 3) readonly buffer TriangleLayer{
	uvec4 Triangles[];
};
layout(std140, binding = 4) uniform KdTreeBlock{
	TreeNode nodeList[TREE_SIZE];
};
layout(std430, binding = 5) readonly buffer NormalLayer{
	vec4 normals[];
};
layout(std430, binding = 6) readonly buffer TexCoordLayer{
	vec2 tex_coords[];
};

const TreeNode treeRoot = nodeList[0];
struct Ray{
	vec3 origin, dir;
	int depth, lastHit;
	vec2 seed;
};
bool RayIntersectsNode(Ray ray, vec3 minBb, vec3 maxBb, float tMin, float tMax, out float t0, out float t1){
	vec3 invD = vec3(1)/vec3(ray.dir);
	vec3 t0s = (minBb - ray.origin) * invD;
  	vec3 t1s = (maxBb - ray.origin) * invD;
    
  	vec3 tsmaller = min(t0s, t1s);
    vec3 tbigger  = max(t0s, t1s);
    
    t0 =  max(tMin, max(tsmaller[0], max(tsmaller[1], tsmaller[2])));
    t1 =  min(tMax, min(tbigger[0], min(tbigger[1], tbigger[2])));

	return (t0 < t1);
}
float RayIntersectsTriangle(Ray ray, vec3 v0, vec3 v1, vec3 v2, out float u, out float v)
{
    vec3 edge1, edge2, h, s, q;
    float a,f,t=0;
    edge1 = v1 - v0;
    edge2 = v2 - v0;
    h = cross(ray.dir, edge2);
    a = dot(edge1, h);
    if (a > -epsilon && a < epsilon)
        return t;    // This ray is parallel to this triangle.
    f = 1.0/a;
    s = ray.origin - v0;
    u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
        return t;
    q = cross(s,edge1);
    v = f * dot(ray.dir, q);
    if (v < 0.0 || u + v > 1.0)
        return t;
    // At this stage we can compute t to find out where the intersection point is on the line.
    t = f * dot(edge2, q);
    return t;
}
struct HitState{
	float t, u, v;
	int id;
}Hit;
struct SearchState{
	int nodeptr; float tMin, tMax;
};
//class Stack{
//	SearchState array[8];
//	int top ;
//	void init(){ top = -1;}
//	SearchState pop(){
//		if(top>=0){
//			SearchState state = array[top];top--; return state;
//		}
//		return SearchState(0,0,0);
//	}
//	void push(SearchState state){ 
//		if(top<array.length()-1){
//			top++; array[top] = state;
//		}
//	}
//	bool empty(){ return top<0; }
//}stack;
void search_tree(Ray ray, TreeNode node, float tMin, float tMax){

	float global_tMin = tMin, global_tMax = tMax;
	tMax = global_tMin; //stack.init();
	TreeNode root = treeRoot; bool push_down;
	while(tMax < global_tMax){
//		if(stack.empty()){node = root; tMin = tMax; tMax = global_tMax; push_down = true;}
//		else{ SearchState state = stack.pop(); node = nodeList[state.nodeptr]; 
//			tMin = state.tMin; tMax = state.tMax; push_down = false;}
		node = root; tMin = tMax; tMax = global_tMax; push_down = true;
		while(node.isLeaf != 1){
			const uint a = node.axis;
			float o = ray.origin[a],d = ray.dir[a];
		
			float tSplit = (node.val-o)/d;
			TreeNode first, second; int sec_ptr;
			if(node.val - o>0){ first = nodeList[node.left]; second = nodeList[node.right]; sec_ptr = node.right;}
			else{ first = nodeList[node.right]; second = nodeList[node.left]; sec_ptr = node.left;}
	
			if(tSplit < 0 || tSplit>=tMax)
				node = first;
			else if(tSplit <= tMin){
				node = second;;
			}
			else{
				//stack.push(SearchState(sec_ptr, tSplit, tMax));
				node = first; tMax = tSplit; push_down = false;
			}
			if(push_down) root = node;
		}

		for(int i = node.firstTriangle; i < node.firstTriangle+node.triangleCount; i++){
			const uvec3 index = uvec3(Triangles[i]);
			const vec4 v0 = Vertices[index.x], v1 = Vertices[index.y],  v2 = Vertices[index.z];
			float _u,_v;
			float _t = RayIntersectsTriangle(ray, vec3(v0), vec3(v1), vec3(v2),_u,_v);
			if(_t < Hit.t && _t > epsilon){
				Hit.t = _t; Hit.u = _u; Hit.v = _v;
				Hit.id = i;
			}
		}
		if(Hit.id != -1) return;	
	}
}

float seed;
float rand(vec2 co){
	seed++;
    return fract(sin(seed/Samples*dot(co ,vec2(12.9898,78.233))) * 43758.5453);
}

vec4 GetRsRp(float n1, float n2, float cos_i){
	cos_i = abs(cos_i);
	float cos_t = sqrt(1 - (n1*n1)/(n2*n2)*(1-cos_i*cos_i));
	float rs = (n1*cos_i-n2*cos_t)/(n1*cos_i+n2*cos_t); 
	float rp = (n1*cos_t-n2*cos_i)/(n1*cos_t+n2*cos_i); 
	float ts = 2*n2*cos_t/(n2*cos_t+n1*cos_i); 
	float tp = 2*n2*cos_t/(n2*cos_i+n1*cos_t);
	return vec4(rs,rp,ts,tp);
}
int randsign(vec2 _seed){
	return rand(_seed)>0.5?1:-1;
}
float GetFaceBBp(vec2 coord){
	const float c = 299792458, k = 138064852e-31, h = 2 * PI * 105457180e-42,
		v = 7.8576538e+02; //first wave length
	const float T = mix(10,37,texture2D(oldman_temp, coord).x)+273.15;
	return 2e8 * (h * c * c * v * v * v) / (exp(100 * h * c * v / k / T) - 1);
}
struct PolarInfo{
	vec3 indir, n, outdir;
};
vec4 Trace(Ray ray){
	vec2[2*MAX_BOUNCE+1] E,R,T; 
	PolarInfo polarInfoList[2*MAX_BOUNCE+1];
	int i;
	//We cannot do recursion in shader, so I use for loop instead
	for(i = 0;i<2*MAX_BOUNCE ;i++){
		//Detect intersection
		Hit.t = inf; Hit.id = -1; Hit.u = 0; Hit.v = 0;

		//Brute force
		for(int j = 0; j < Triangles.length(); j++){
			const vec4 v0 = Vertices[Triangles[j].x], v1 = Vertices[Triangles[j].y],  v2 = Vertices[Triangles[j].z];
			float _u,_v;
			float _t = RayIntersectsTriangle(ray, vec3(v0), vec3(v1), vec3(v2), _u, _v);
			if(_t < Hit.t && _t > epsilon){
			Hit.t = _t; Hit.u = _u; Hit.v = _v;
			Hit.id = j;
			}
		}
		//search kd tree
//		Hit.t = inf; Hit.id = -1;
//		float tMin, tMax;
//		if(RayIntersectsNode(ray, vec3(0), vec3(300), -1e5, 1e5, tMin, tMax)){
//			search_tree(ray, treeRoot, tMin, tMax);
//			if(Hit.id != -1 && t > Hit.t){
//				t = Hit.t; id = int(Hit.id);
//				object = 2;
//			}
//		}
		/*---------------------------*/
		if(Hit.id == -1 ){ E[i] = vec2(epsilon); break;}
		Hit.t-=0.05;if(Hit.t<epsilon)break;

		vec3 normal, hit = ray.origin + ray.dir*Hit.t; int type;

		const uvec4 tri = Triangles[Hit.id]; type = CSdataList[tri.w].type;
		const vec3 v0 = vec3(Vertices[tri.x]), v1 = vec3(Vertices[tri.y]), v2 = vec3(Vertices[tri.z]); 
		vec2 uv = (1-Hit.u-Hit.v)*tex_coords[tri.x]+Hit.u*tex_coords[tri.y]+Hit.v*tex_coords[tri.z];

		vec4 _normal = (1-Hit.u-Hit.v)*normals[tri.x]+Hit.u*normals[tri.y]+Hit.v*normals[tri.z];
		normal = vec3(normalize(_normal));
		//normal = normalize(cross(v0-v1,v0-v2));

		//internal reflection/refraction or not
		vec3 n = dot(normal,ray.dir)>0? -normal:normal;
		vec3 inDir = ray.dir;
		//Different BRDFs
		if(type == SPECULAR){
			ray.dir = reflect(ray.dir,n);
		}
		else if(type == DIFFUSE){
			//Monte Carlo Integration
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),n):cross(vec3(1),n);
			u = normalize(u);
			vec3 v = cross(u,n);
			float w = rand(ray.seed), theta = rand(ray.seed);
			//uniformly sampling on hemisphere
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*n;
			ray.dir = d;
		}
		else if(type == REFRACTION){
			float nc = 1.0, ng = 1.5; //Refraction index
			bool inside = dot(normal,n)<0;
			//Snells Law
			float eta = inside? ng/nc : nc/ng, R0 = pow((nc-ng)/(nc+ng), 2), c = abs(dot(ray.dir, n));
			float k = 1.0 - eta * eta * (1.0 - c*c);
			if(k < 0)
				ray.dir = reflect(ray.dir, n);
			else{
				//Shilick's approximation of Fresnel's equation
				float Re = R0 + (1-R0)*pow(1-c,5);
				if(abs(rand(ray.seed))<Re)
					ray.dir = reflect(ray.dir, n);
				else{
					ray.dir= (eta * ray.dir - (eta * dot(n, ray.dir) + sqrt(k)) * n);
				}
			}
		}else if(type == GLOSSY){
			vec3 r = reflect(ray.dir, n);
			vec3 u = abs(n.x) < 1-epsilon? cross(vec3(1,0,0),r):cross(vec3(1),r);
			u = normalize(u);
			vec3 v = cross(u,r);
			float w = rand(ray.seed) * glossiness, theta = rand(ray.seed);
			vec3 d = w*cos(2*PI*theta)*u + w*sin(2*PI*theta)*v + sqrt(1-w*w)*r;
			ray.dir = d;
		}
		n = normalize(ray.dir-inDir);
		ray.origin = hit;
		ray.lastHit = Hit.id;
		vec4 RT = GetRsRp(1.0f, 1.1f, dot(n, ray.dir));
		R[i] = RT.xy; T[i] = RT.zw;
		E[i] = sqrt(vec2(texture2D(oldman_temp,uv).x/2.f))*vec2(randsign(ray.seed), randsign(ray.seed));
		
		
		polarInfoList[i] = PolarInfo(inDir, n, ray.dir);

		//Russian Roulette Path Termination
		float p = min(0.95, max(abs(E[i].x), abs(E[i].y)));
		if(i >= MAX_BOUNCE)
			if(rand(ray.seed)>p){
				break;
			}
	}
	//R & I are reflectivity and intensity, i is reflection times plus one
	vec2 res = vec2(E[i--]); int i_max = i;
	float E_total = length(res); vec3 Polar = normalize(vec3(rand(ray.seed),rand(ray.seed),rand(ray.seed))-0.5); vec3 s,p;
	for(; i >= 0;i--){
		//PolarInfo{ indir, normal, outdir}
		vec3 d = polarInfoList[i].outdir;
		s = normalize(cross(polarInfoList[i].n, d));
		p = normalize(cross(d,s));

		float a = dot(Polar,s), b = dot(Polar, p);
		vec2 sign_res = sign(vec2(a,b));
		res = E_total*vec2(a,b);

		res = E[i]*T[i] + R[i]*res;
		E_total = length(res);

		p = normalize(cross(polarInfoList[i].indir,s));
		
		Polar = res.x/E_total * s + res.y/E_total * p;
	}
	
	float x = Polar.x, y = Polar.y;
	//return E_total*E_total*vec4(x*x);
	return E_total*E_total*vec4(x*x,y*y,(x+y)*(x+y)/2.f,(x-y)*(x-y)/2.f);
}
void main(void)
{
	ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
	ivec2 size = imageSize(result);
	if(pixel.x>=size.x || pixel.y>=size.y)
		return;
	//start ray tracing

	vec2 pos = vec2(pixel)/vec2(size);
	pos += vec2(rand(pixel), rand(pixel))*2e-3;//MSAA
	vec3 dir = mix(mix(ray00,ray10,pos.x), mix(ray01,ray11,pos.x), pos.y);
	
	vec4 color = Trace(Ray(camPos, normalize(dir), 0 , -1 ,pixel));

	pixel.y = size.y - pixel.y - 1;
	color += imageLoad(result, pixel)*(Samples-1);
	barrier();
	imageStore(result, pixel, color/Samples);
}